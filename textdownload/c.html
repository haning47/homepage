<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>批次下載（松山高中 - 限 sssh.tp.edu.tw）</title>
<style>
body{font-family:"Noto Sans TC",sans-serif;background:#f4f4f4;color:#333;padding:24px;text-align:center}
input,button{padding:10px 14px;font-size:16px;margin:6px;border-radius:6px;border:0;cursor:pointer}
button{background:#0a5c44;color:#fff}
#log{max-width:900px;margin:18px auto;text-align:left;background:#fff;padding:18px;border-radius:8px;box-shadow:0 2px 6px rgba(0,0,0,0.06)}
a.download-link{display:block;margin:6px 0;color:#0a5c44;text-decoration:none}
</style>
</head>
<body>
<h2>📥 批次下載（僅 https://www.sssh.tp.edu.tw）</h2>
<p>輸入要抓取的松山高中網頁網址（例如：https://www.sssh.tp.edu.tw/... ）</p>
<input id="urlInput" placeholder="輸入網址..." size="60" />
<button id="fetchBtn">抓取連結</button>
<button id="downloadAllBtn" disabled>全部下載</button>
<div id="log"></div>

<script>
/*
 改良邏輯：
 1) 會依序嘗試多個公開 CORS 代理（若其中一個成功則停止）
 2) 仍會僅保留以 https://www.sssh.tp.edu.tw 開頭的連結
 3) 若全部代理都失敗，會顯示可能原因與建議
 注意：公共代理並非百分之百可靠；最穩的方法是自建 proxy（以下回應有範例）
*/
const proxies = [
  (u)=>`https://api.allorigins.win/raw?url=${encodeURIComponent(u)}`, // 取得 raw 內容
  (u)=>`https://api.allorigins.win/get?url=${encodeURIComponent(u)}`, // 回傳 json.contents（備援）
  (u)=>`https://thingproxy.freeboard.io/fetch/${encodeURIComponent(u)}` // 備援代理
];

let foundLinks = [];

function log(msg, isHtml=false){
  const el = document.getElementById('log');
  if(isHtml) el.innerHTML = msg;
  else el.innerText = msg;
}

async function fetchViaProxy(url){
  // 依序嘗試 proxies；回傳 text 或 throw
  for(const p of proxies){
    const api = p(url);
    try{
      const r = await fetch(api);
      if(!r.ok) throw new Error(`proxy ${api} 回傳 ${r.status}`);
      // allorigins.raw 會直接回傳 text； allorigins.get 回傳 json
      const ct = r.headers.get('content-type') || '';
      if(ct.includes('application/json') || api.includes('/get?')) {
        const j = await r.json();
        // allorigins get 回傳 {contents: "..."}，thingproxy 也可能回 json
        if(j && j.contents) return j.contents;
        // 若 json 但沒有 contents，嘗試轉為 string
        return JSON.stringify(j);
      } else {
        // 直接回 text
        return await r.text();
      }
    }catch(e){
      // 嘗試下一個 proxy（記錄但不立即拋錯）
      console.warn('proxy failed', p(url), e.message);
      continue;
    }
  }
  throw new Error('所有公開代理皆失敗（可能被封鎖或目標需驗證 / 為非公開內容）');
}

document.getElementById('fetchBtn').addEventListener('click', async ()=>{
  const url = document.getElementById('urlInput').value.trim();
  const downloadAllBtn = document.getElementById('downloadAllBtn');
  foundLinks = [];
  downloadAllBtn.disabled = true;
  if(!url){ log('⚠️ 請輸入網址'); return; }
  log('⏳ 正在透過代理抓取頁面，若失敗會顯示原因（請耐心等候）...', true);

  try{
    // 有可能 target 為 http 而你的頁面是 https（會被瀏覽器預先阻擋）— 提醒檢查
    if(url.startsWith('http:') && location.protocol === 'https:'){
      log('❗ 注意：你的 GitHub Pages 為 HTTPS，但目標為 HTTP（瀏覽器可能會阻擋 mixed content）。請改用 http 於本機測試或架 proxy。', true);
    }

    const text = await fetchViaProxy(url);
    // 若 allorigins.get 回傳 JSON 字串，上面會轉成 JSON string — 嘗試 parse 為 html text
    const parser = new DOMParser();
    const doc = parser.parseFromString(text, 'text/html');
    const links = doc.querySelectorAll('a[href]');
    const targetPrefix = 'https://www.sssh.tp.edu.tw';
    let count = 0;
    const logContainer = document.createElement('div');

    links.forEach(link=>{
      const href = link.getAttribute('href');
      const label = (link.textContent || '未命名').trim();
      if(!href || href.startsWith('#')) return;
      const absUrl = new URL(href, url).href;
      if(!absUrl.startsWith(targetPrefix)) return;
      // 取副檔名（從 URL path）
      const pathname = (new URL(absUrl)).pathname;
      const idx = pathname.lastIndexOf('.');
      const ext = (idx>-1) ? pathname.slice(idx) : '';
      const safeName = label.replace(/[\\\/:*?"<>|]/g,'_') + ext;
      foundLinks.push({name: safeName, url: absUrl});
      const a = document.createElement('a');
      a.href = absUrl; a.download = safeName; a.target='_blank';
      a.className = 'download-link';
      a.textContent = `下載：${safeName} → ${absUrl}`;
      logContainer.appendChild(a);
      count++;
    });

    if(count===0){
      log('⚠️ 找不到符合條件的連結（僅限 https://www.sssh.tp.edu.tw 開頭）。', true);
      return;
    }
    document.getElementById('log').innerHTML = `<h3>✅ 找到 ${count} 個可下載檔案：</h3>`;
    document.getElementById('log').appendChild(logContainer);
    downloadAllBtn.disabled = false;

  }catch(err){
    // 若 fetchViaProxy 拋錯，顯示詳細說明（含建議）
    const msg = `❌ 錯誤：${err.message}\n\n可能原因：\n` +
      `1) 目標網站需登入或有防爬機制（公共代理無法通過）。\n` +
      `2) 目標或代理被封鎖或目前當機。\n` +
      `3) 你的頁面為 HTTPS，但目標是 HTTP（mixed content 會被阻擋）。\n\n建議：\n` +
      `• 若可，改用「自建 proxy」（Cloudflare Worker 或小型 Node 伺服器）。\n` +
      `• 或在本機臨時以瀏覽器關閉 CORS 測試（僅開發用）。\n` +
      `• 我可提供自建 proxy 的程式範例（Cloudflare Worker 與 Node）。`;
    document.getElementById('log').innerText = msg;
    console.error(err);
  }
});

document.getElementById('downloadAllBtn').addEventListener('click', ()=>{
  if(foundLinks.length===0) return;
  let delay = 0;
  foundLinks.forEach(f=>{
    setTimeout(()=>{
      const a = document.createElement('a');
      a.href = f.url;
      a.download = f.name;
      a.click();
    }, delay);
    delay += 700;
  });
});
</script>
</body>
</html>
